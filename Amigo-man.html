<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>amigo-man</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press-Start-2P', cursive;
            touch-action: none; /* Disabilita il pinch-to-zoom e altri gesti touch */
            overflow: hidden; /* Nasconde le barre di scorrimento */
        }
        canvas {
            background-color: black;
            display: block;
        }
        .touch-control-button {
            transition: transform 0.1s ease-in-out;
        }
        .touch-control-button:active {
            transform: scale(0.9);
        }
        .blink {
            animation: blinker 0.5s linear infinite;
        }
        @keyframes blinker {
            50% {
                opacity: 0.5;
            }
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center h-screen overflow-hidden">

    <div id="game-container" class="w-full max-w-lg md:max-w-xl lg:max-w-2xl flex flex-col items-center p-2">
        <!-- Informazioni di gioco -->
        <div class="w-full flex justify-between items-center mb-2 px-2 text-xs sm:text-base">
            <h1 class="text-lg sm:text-xl md:text-2xl text-yellow-400">amigo-man</h1>
            <div>
                <span>LIVELLO: </span><span id="levelEl" class="text-yellow-400">1</span>
            </div>
             <div>
                <span>BEST: </span><span id="bestScoreEl" class="text-yellow-400">0</span>
            </div>
            <div>
                <span>PUNTEGGIO: </span><span id="scoreEl" class="text-yellow-400">0</span>
            </div>
        </div>

        <!-- Canvas del gioco -->
        <div class="relative w-full" style="padding-bottom: 115%;"> <!-- Aspect ratio container -->
             <canvas id="gameCanvas" class="absolute top-0 left-0 w-full h-full rounded-lg border-4 border-blue-600 shadow-lg"></canvas>
             <div id="startScreen" class="absolute inset-0 bg-black bg-opacity-70 flex flex-col justify-center items-center text-center p-4">
                <h2 class="text-3xl text-yellow-400 mb-4">BENVENUTO!</h2>
                <p class="mb-6">Usa i tasti freccia o i controlli touch per muoverti.</p>
                <button id="startButton" class="bg-yellow-400 text-black px-6 py-3 rounded-lg text-xl hover:bg-yellow-500 transition-colors">INIZIA GIOCO</button>
            </div>
             <div id="gameOverScreen" class="absolute inset-0 bg-black bg-opacity-70 flex flex-col justify-center items-center text-center p-4 hidden">
                <h2 class="text-4xl text-red-500 mb-4">GAME OVER</h2>
                <p id="gameOverMessage" class="text-sm mb-4 text-yellow-300 px-2"></p>
                <p class="mb-6 text-xl">Punteggio finale: <span id="finalScore" class="text-yellow-400">0</span></p>
                <button id="restartButton" class="bg-yellow-400 text-black px-6 py-3 rounded-lg text-xl hover:bg-yellow-500 transition-colors">RICOMINCIA</button>
            </div>
             <div id="levelCompleteScreen" class="absolute inset-0 bg-black bg-opacity-70 flex flex-col justify-center items-center text-center p-4 hidden">
                <h2 class="text-3xl text-green-400 mb-4">LIVELLO COMPLETATO!</h2>
                <p class="text-xl">Preparati per il prossimo livello...</p>
            </div>
        </div>
    </div>

    <!-- Controlli Touch per mobile -->
    <div id="touch-controls" class="mt-4 grid grid-cols-3 gap-2 w-48 md:hidden">
        <div></div>
        <button id="up-btn" class="touch-control-button bg-blue-600 p-4 rounded-lg shadow-md text-2xl">▲</button>
        <div></div>
        <button id="left-btn" class="touch-control-button bg-blue-600 p-4 rounded-lg shadow-md text-2xl">◀</button>
        <button id="down-btn" class="touch-control-button bg-blue-600 p-4 rounded-lg shadow-md text-2xl">▼</button>
        <button id="right-btn" class="touch-control-button bg-blue-600 p-4 rounded-lg shadow-md text-2xl">▶</button>
    </div>

    <script>
        // Ottiene gli elementi del DOM
        const canvas = document.getElementById('gameCanvas');
        const c = canvas.getContext('2d');
        const scoreEl = document.getElementById('scoreEl');
        const levelEl = document.getElementById('levelEl');
        const bestScoreEl = document.getElementById('bestScoreEl');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const gameOverMessage = document.getElementById('gameOverMessage');
        const levelCompleteScreen = document.getElementById('levelCompleteScreen');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const finalScore = document.getElementById('finalScore');
        
        // Impostazioni iniziali
        let tileSize;
        let score = 0;
        let bestScore = 0;
        let level = 1;
        let pellets = [];
        let powerUps = [];
        let boundaries = [];
        let ghosts = [];
        let player;
        let animationId;
        const playerSpeed = 4;
        let keys = {
            up: { pressed: false },
            down: { pressed: false },
            left: { pressed: false },
            right: { pressed: false }
        };
        let lastKey = '';

        // Carica il punteggio migliore
        bestScore = localStorage.getItem('amigoManBestScore') || 0;
        bestScoreEl.innerHTML = bestScore;

        // Mappa del labirinto
        const map = [
            ['1', '-', '-', '-', '-', '-', '-', '-', '-', '-', '2'],
            ['|', '.', '.', '.', '.', '.', '.', '.', '.', '.', '|'],
            ['|', '.', 'b', '.', '[', '7', ']', '.', 'b', '.', '|'],
            ['|', '.', '.', '.', '.', '_', '.', '.', '.', '.', '|'],
            ['|', '.', '[', ']', '.', '.', '.', '[', ']', '.', '|'],
            ['|', '.', '.', '.', '.', '^', '.', '.', '.', '.', '|'],
            ['|', '.', 'b', '.', '[', '+', ']', '.', 'b', '.', '|'],
            ['|', '.', '.', '.', '.', '_', '.', '.', '.', '.', '|'],
            ['|', '.', '[', ']', '.', '.', '.', '[', ']', '.', '|'],
            ['|', '.', '.', '.', '.', '^', '.', '.', '.', '.', '|'],
            ['|', '.', 'b', '.', '[', '5', ']', '.', 'b', '.', '|'],
            ['|', '.', '.', '.', '.', '.', '.', '.', '.', 'p', '|'],
            ['4', '-', '-', '-', '-', '-', '-', '-', '-', '-', '3']
        ];
        
        // Suoni del gioco con Tone.js
        const synth = new Tone.Synth().toDestination();
        const chompSynth = new Tone.MembraneSynth().toDestination();
        const deathSynth = new Tone.FMSynth().toDestination();
        
        function playChompSound() { chompSynth.triggerAttackRelease("C1", "8n"); }
        function playPowerUpSound() { synth.triggerAttackRelease("C5", "8n"); }
        function playEatGhostSound() { synth.triggerAttackRelease("E5", "8n"); }
        function playDeathSound() {
            deathSynth.triggerAttackRelease("C3", "8n", Tone.now());
            deathSynth.triggerAttackRelease("G2", "8n", Tone.now() + 0.2);
            deathSynth.triggerAttackRelease("E2", "8n", Tone.now() + 0.4);
            deathSynth.triggerAttackRelease("C2", "4n", Tone.now() + 0.6);
        }
        
        // Caricamento Immagini
        const playerImage = new Image();
        playerImage.src = 'https://i.imgur.com/aoFVRBR.png';

        const powerUpImageBeer = new Image();
        powerUpImageBeer.src = 'https://em-content.zobj.net/source/apple/419/beer-mug_1f37a.png';
        const powerUpImageMirrorBall = new Image();
        powerUpImageMirrorBall.src = 'https://em-content.zobj.net/source/apple/419/mirror-ball_1faa9.png';
        const powerUpImagePlayer = new Image();
        powerUpImagePlayer.src = 'https://i.imgur.com/aoFVRBR.png';
        const powerUpImages = [powerUpImageBeer, powerUpImageMirrorBall, powerUpImagePlayer];
        let currentPowerUpImage;

        const ghostRedImage = new Image();
        ghostRedImage.src = 'https://em-content.zobj.net/source/apple/419/books_1f4da.png';
        const ghostOrangeImage = new Image();
        ghostOrangeImage.src = 'https://em-content.zobj.net/source/apple/419/speaking-head_1f5e3-fe0f.png';
        const ghostCyanImage = new Image();
        ghostCyanImage.src = 'https://em-content.zobj.net/source/samsung/411/incoming-envelope_1f4e8.png';
        const ghostPinkImage = new Image();
        ghostPinkImage.src = 'https://em-content.zobj.net/source/apple/419/receipt_1f9fe.png';

        class Boundary {
            constructor({ position }) {
                this.position = position;
                this.width = tileSize;
                this.height = tileSize;
            }
            draw() {
                c.fillStyle = '#0000FF';
                c.fillRect(this.position.x, this.position.y, this.width, this.height);
            }
        }
        
        class Player {
            constructor({ position, velocity }) {
                this.position = position;
                this.velocity = velocity;
                this.radius = tileSize / 2 - 2;
                this.facingRight = true;
            }
            draw() {
                c.save();
                c.translate(this.position.x, this.position.y);
                
                if (!this.facingRight) {
                    c.scale(-1, 1);
                }

                c.drawImage(
                    playerImage,
                    -this.radius,
                    -this.radius,
                    this.radius * 2,
                    this.radius * 2
                );
                c.restore();
            }
            update() {
                this.draw();
                this.position.x += this.velocity.x;
                this.position.y += this.velocity.y;

                if (this.velocity.x > 0) this.facingRight = true;
                else if (this.velocity.x < 0) this.facingRight = false;
            }
        }
        
        class Ghost {
            constructor({ position, velocity, image, name }) {
                this.position = position;
                this.velocity = velocity;
                this.radius = tileSize / 2 - 2;
                this.image = image;
                this.name = name; // Nome del fantasma
                this.scared = false;
                this.speed = 1.5 + (level - 1) * 0.2;
            }
            draw() {
                if (this.scared) {
                    c.beginPath();
                    c.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
                    c.fillStyle = '#191970';
                    c.fill();
                    c.closePath();
                    c.globalAlpha = 0.5 + Math.sin(Date.now() / 100) * 0.2;
                    c.beginPath();
                    c.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
                    c.fillStyle = 'white';
                    c.fill();
                    c.closePath();
                    c.globalAlpha = 1.0;
                } else {
                    c.drawImage(
                        this.image,
                        this.position.x - this.radius,
                        this.position.y - this.radius,
                        this.radius * 2,
                        this.radius * 2
                    );
                }
            }
            update() {
                this.draw();
                this.position.x += this.velocity.x;
                this.position.y += this.velocity.y;
            }
        }
        
        class Pellet {
            constructor({ position }) { this.position = position; this.radius = Math.max(1, tileSize / 10); }
            draw() {
                c.beginPath();
                c.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
                c.fillStyle = 'white';
                c.fill();
                c.closePath();
            }
        }
        
        class PowerUp {
            constructor({ position, image }) {
                this.position = position;
                this.image = image;
                this.radius = tileSize / 2 * 0.7;
                this.width = this.radius * 2;
                this.height = this.radius * 2;
            }
            draw() {
                const drawX = this.position.x - this.width / 2;
                const drawY = this.position.y - this.height / 2;
                c.drawImage(this.image, drawX, drawY, this.width, this.height);
            }
        }
        
        function circleCollidesWithRectangle({ circle, rectangle }) {
            const padding = tileSize / 2 - circle.radius - 1;
            return (
                circle.position.y - circle.radius + circle.velocity.y <= rectangle.position.y + rectangle.height + padding &&
                circle.position.x + circle.radius + circle.velocity.x >= rectangle.position.x - padding &&
                circle.position.y + circle.radius + circle.velocity.y >= rectangle.position.y - padding &&
                circle.position.x - circle.radius + circle.velocity.x <= rectangle.position.x + rectangle.width + padding
            );
        }
        
        function getGhostDirection(ghost) {
            if (ghost.velocity.y < 0) return 'up';
            if (ghost.velocity.y > 0) return 'down';
            if (ghost.velocity.x < 0) return 'left';
            if (ghost.velocity.x > 0) return 'right';
            return '';
        }

        function initLevel() {
            pellets = []; powerUps = []; boundaries = []; ghosts = [];
            keys = { up: { pressed: false }, down: { pressed: false }, left: { pressed: false }, right: { pressed: false } };
            lastKey = '';
            levelEl.innerHTML = level;
            tileSize = 40;
            canvas.width = map[0].length * tileSize;
            canvas.height = map.length * tileSize;
            
            currentPowerUpImage = powerUpImages[Math.floor(Math.random() * powerUpImages.length)];

            map.forEach((row, i) => {
                row.forEach((symbol, j) => {
                    const position = { x: tileSize * j + tileSize / 2, y: tileSize * i + tileSize / 2 };
                    const boundaryPosition = { x: tileSize * j, y: tileSize * i };
                    switch (symbol) {
                        case '.': pellets.push(new Pellet({ position })); break;
                        case 'p': powerUps.push(new PowerUp({ position, image: currentPowerUpImage })); break;
                        case ' ': break;
                        default: boundaries.push(new Boundary({ position: boundaryPosition })); break;
                    }
                });
            });
            
            player = new Player({ position: { x: tileSize + tileSize / 2, y: tileSize + tileSize / 2 }, velocity: { x: 0, y: 0 } });

            const ghostSpeed = 1.5 + (level - 1) * 0.2;
            ghosts = [
                new Ghost({ position: { x: tileSize * 6 + tileSize / 2, y: tileSize + tileSize / 2 }, velocity: { x: ghostSpeed, y: 0 }, image: ghostRedImage, name: 'i libri' }),
                new Ghost({ position: { x: tileSize * 6 + tileSize / 2, y: tileSize * 3 + tileSize / 2 }, velocity: { x: ghostSpeed, y: 0 }, image: ghostPinkImage, name: 'lo scontrino' }),
                new Ghost({ position: { x: tileSize * 8 + tileSize / 2, y: tileSize * 9 + tileSize / 2 }, velocity: { x: 0, y: ghostSpeed }, image: ghostCyanImage, name: 'la mail' }),
                new Ghost({ position: { x: tileSize * 3 + tileSize / 2, y: tileSize * 11 + tileSize / 2 }, velocity: { x: 0, y: -ghostSpeed }, image: ghostOrangeImage, name: 'la testa parlante' })
            ];
        }

        function animate() {
            animationId = requestAnimationFrame(animate);
            c.clearRect(0, 0, canvas.width, canvas.height);

            if (keys.up.pressed && lastKey === 'up') {
                let collision = boundaries.some(boundary => circleCollidesWithRectangle({ circle: { ...player, velocity: { x: 0, y: -playerSpeed } }, rectangle: boundary }));
                if (!collision) {
                    player.velocity.x = 0;
                    player.velocity.y = -playerSpeed;
                }
            } else if (keys.down.pressed && lastKey === 'down') {
                let collision = boundaries.some(boundary => circleCollidesWithRectangle({ circle: { ...player, velocity: { x: 0, y: playerSpeed } }, rectangle: boundary }));
                if (!collision) {
                    player.velocity.x = 0;
                    player.velocity.y = playerSpeed;
                }
            } else if (keys.left.pressed && lastKey === 'left') {
                let collision = boundaries.some(boundary => circleCollidesWithRectangle({ circle: { ...player, velocity: { x: -playerSpeed, y: 0 } }, rectangle: boundary }));
                if (!collision) {
                    player.velocity.x = -playerSpeed;
                    player.velocity.y = 0;
                }
            } else if (keys.right.pressed && lastKey === 'right') {
                let collision = boundaries.some(boundary => circleCollidesWithRectangle({ circle: { ...player, velocity: { x: playerSpeed, y: 0 } }, rectangle: boundary }));
                if (!collision) {
                    player.velocity.x = playerSpeed;
                    player.velocity.y = 0;
                }
            }

            let willCollide = boundaries.some(boundary => circleCollidesWithRectangle({ circle: { ...player, velocity: player.velocity }, rectangle: boundary }));
            if (willCollide) {
                player.velocity.x = 0;
                player.velocity.y = 0;
            }

            boundaries.forEach(boundary => boundary.draw());

            for (let i = pellets.length - 1; i >= 0; i--) {
                const pellet = pellets[i];
                pellet.draw();
                if (Math.hypot(pellet.position.x - player.position.x, pellet.position.y - player.position.y) < pellet.radius + player.radius) {
                    pellets.splice(i, 1);
                    score += 10;
                    scoreEl.innerHTML = score;
                    playChompSound();
                }
            }
            
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const powerUp = powerUps[i];
                powerUp.draw();
                if (Math.hypot(powerUp.position.x - player.position.x, powerUp.position.y - player.position.y) < powerUp.radius + player.radius) {
                    powerUps.splice(i, 1);
                    playPowerUpSound();
                    ghosts.forEach(ghost => {
                        ghost.scared = true;
                        setTimeout(() => { ghost.scared = false; }, 3000);
                    });
                }
            }
            
            player.update();

            ghosts.forEach((ghost) => {
                if (Math.hypot(ghost.position.x - player.position.x, ghost.position.y - player.position.y) < ghost.radius + player.radius) {
                    if (ghost.scared) {
                        const index = ghosts.indexOf(ghost);
                        if (index > -1) ghosts.splice(index, 1);
                        score += 100;
                        scoreEl.innerHTML = score;
                        playEatGhostSound();
                    } else {
                        cancelAnimationFrame(animationId);
                        
                        let message = '';
                        switch (ghost.name) {
                            case 'i libri':
                                message = "Cavolo amigo, la prossima volta lo passi l'esame";
                                break;
                            case 'la testa parlante':
                                message = "Cavolo amigo, la gente non smette proprio di parlare, vero?";
                                break;
                            case 'lo scontrino':
                                message = "Cavolo amigo, mai pagare la cena alla 10/10";
                                break;
                            case 'la mail':
                                message = "Cavolo amigo, prima o poi dovevi rispondere alle mail di lavoro";
                                break;
                        }
                        gameOverMessage.textContent = message;

                        if (score > bestScore) {
                            bestScore = score;
                            localStorage.setItem('amigoManBestScore', bestScore);
                            bestScoreEl.innerHTML = bestScore;
                        }

                        gameOverScreen.classList.remove('hidden');
                        finalScore.textContent = score;
                        playDeathSound();
                    }
                }

                const collisions = [];
                boundaries.forEach(boundary => {
                    if (!collisions.includes('right') && circleCollidesWithRectangle({ circle: { ...ghost, velocity: { x: ghost.speed, y: 0 } }, rectangle: boundary })) collisions.push('right');
                    if (!collisions.includes('left') && circleCollidesWithRectangle({ circle: { ...ghost, velocity: { x: -ghost.speed, y: 0 } }, rectangle: boundary })) collisions.push('left');
                    if (!collisions.includes('up') && circleCollidesWithRectangle({ circle: { ...ghost, velocity: { x: 0, y: -ghost.speed } }, rectangle: boundary })) collisions.push('up');
                    if (!collisions.includes('down') && circleCollidesWithRectangle({ circle: { ...ghost, velocity: { x: 0, y: ghost.speed } }, rectangle: boundary })) collisions.push('down');
                });

                if (collisions.includes(getGhostDirection(ghost))) {
                    const pathways = [];
                    const directions = ['right', 'left', 'up', 'down'];
                    directions.forEach(direction => {
                        if (!collisions.includes(direction)) {
                            pathways.push(direction);
                        }
                    });

                    if (pathways.length > 0) {
                        const newDirection = pathways[Math.floor(Math.random() * pathways.length)];
                        switch (newDirection) {
                            case 'up': ghost.velocity = { x: 0, y: -ghost.speed }; break;
                            case 'down': ghost.velocity = { x: 0, y: ghost.speed }; break;
                            case 'left': ghost.velocity = { x: -ghost.speed, y: 0 }; break;
                            case 'right': ghost.velocity = { x: ghost.speed, y: 0 }; break;
                        }
                    }
                }
                
                ghost.update();
            });

            if (pellets.length === 0) {
                cancelAnimationFrame(animationId);
                levelCompleteScreen.classList.remove('hidden');
                setTimeout(nextLevel, 3000);
            }
        }

        function nextLevel() {
            level++;
            levelCompleteScreen.classList.add('hidden');
            initLevel();
            animate();
        }
        
        function startNewGame() {
            Tone.start();
            score = 0;
            level = 1;
            scoreEl.innerHTML = score;
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            levelCompleteScreen.classList.add('hidden');
            initLevel();
            animate();
        }
        
        startButton.addEventListener('click', startNewGame);
        restartButton.addEventListener('click', startNewGame);

        window.addEventListener('keydown', ({ key }) => {
            switch (key) {
                case 'w': case 'ArrowUp': keys.up.pressed = true; lastKey = 'up'; break;
                case 's': case 'ArrowDown': keys.down.pressed = true; lastKey = 'down'; break;
                case 'a': case 'ArrowLeft': keys.left.pressed = true; lastKey = 'left'; break;
                case 'd': case 'ArrowRight': keys.right.pressed = true; lastKey = 'right'; break;
            }
        });

        window.addEventListener('keyup', ({ key }) => {
            switch (key) {
                case 'w': case 'ArrowUp': keys.up.pressed = false; break;
                case 's': case 'ArrowDown': keys.down.pressed = false; break;
                case 'a': case 'ArrowLeft': keys.left.pressed = false; break;
                case 'd': case 'ArrowRight': keys.right.pressed = false; break;
            }
        });

        const controls = { 'up-btn': 'up', 'down-btn': 'down', 'left-btn': 'left', 'right-btn': 'right' };
        for (const [id, direction] of Object.entries(controls)) {
            const btn = document.getElementById(id);
            btn.addEventListener('touchstart', (e) => { e.preventDefault(); keys[direction].pressed = true; lastKey = direction; });
            btn.addEventListener('touchend', (e) => { e.preventDefault(); keys[direction].pressed = false; });
        }
    </script>
</body>
</html>
